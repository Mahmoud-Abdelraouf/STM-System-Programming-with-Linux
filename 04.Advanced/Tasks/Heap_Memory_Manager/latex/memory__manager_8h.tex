\doxysection{memory\+\_\+manager.\+h File Reference}
\hypertarget{memory__manager_8h}{}\label{memory__manager_8h}\index{memory\_manager.h@{memory\_manager.h}}


Header file for the Memory Manager module.  


{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include "{}glthread.\+h"{}}\newline
Include dependency graph for memory\+\_\+manager.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=218pt]{memory__manager_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=195pt]{memory__manager_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structblock__meta__data__}{block\+\_\+meta\+\_\+data\+\_\+}}
\begin{DoxyCompactList}\small\item\em Structure representing metadata for a memory block. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structvm__page__}{vm\+\_\+page\+\_\+}}
\begin{DoxyCompactList}\small\item\em Structure representing a virtual memory page. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structvm__page__family__}{vm\+\_\+page\+\_\+family\+\_\+}}
\begin{DoxyCompactList}\small\item\em Structure representing a page family in virtual memory. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structvm__page__for__families__}{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+}}
\begin{DoxyCompactList}\small\item\em Structure representing a virtual memory page containing families of memory structures. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{memory__manager_8h_a7e33ad2337bb751f178af9eebc45a84d}{MM\+\_\+\+MAX\+\_\+\+STRUCT\+\_\+\+NAME}}~32
\item 
\#define \mbox{\hyperlink{memory__manager_8h_a56d7beb47f6bbf896e6f21fb09c73ec5}{MAX\+\_\+\+STRUCT\+\_\+\+NAME\+\_\+\+LEN}}~50
\item 
\#define \mbox{\hyperlink{memory__manager_8h_a1144c25dd2f4ee38d1825adf4a316a27}{MAX\+\_\+\+FAMILIES\+\_\+\+PER\+\_\+\+VM\+\_\+\+PAGE}}
\begin{DoxyCompactList}\small\item\em Maximum number of families that can be stored in a single virtual memory page. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_ac15f4fa9d6b78fc0ff539a7d1d4b64d2}{ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+BEGIN}}(vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro for beginning iteration over page families. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_ade62c3641f42fba45136e760112aca9c}{ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+END}}(vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro marking the end of iteration over families within a virtual memory page. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_ac631f611777465204532dc3ab987b332}{ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+BEGIN}}(vm\+\_\+page\+\_\+family\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro to iterate over virtual memory pages beginning from the first page of a page family. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a596be76ddc13d22fa0fe655e5dd58931}{ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+END}}(vm\+\_\+page\+\_\+family\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro marking the end of the iteration over virtual memory pages. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_ac163a8510af79f4a2e157f664a0a73cc}{ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+BEGIN}}(vm\+\_\+page\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro to begin iteration over all memory blocks within a virtual memory page. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a54793f38cfc42b2f461e3b198efa9a1e}{ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+END}}(vm\+\_\+page\+\_\+ptr,  curr)
\begin{DoxyCompactList}\small\item\em Macro to end iteration over all memory blocks within a virtual memory page. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a53981175c7d4dcad912920a3ab7626ae}{offset\+\_\+of}}(container\+\_\+structure,  field\+\_\+name)~  ((size\+\_\+t)(\&((container\+\_\+structure \texorpdfstring{$\ast$}{*})0)-\/$>$field\+\_\+name))
\begin{DoxyCompactList}\small\item\em Macro to calculate the offset of a field within a structure. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a8b33c3f061b53c0229ff71ef0b291595}{MM\+\_\+\+GET\+\_\+\+PAGE\+\_\+\+FROM\+\_\+\+META\+\_\+\+BLOCK}}(block\+\_\+meta\+\_\+data\+\_\+ptr)~  ((void \texorpdfstring{$\ast$}{*})((char \texorpdfstring{$\ast$}{*})(block\+\_\+meta\+\_\+data\+\_\+ptr) -\/ (block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$offset))
\begin{DoxyCompactList}\small\item\em Macro to retrieve the virtual memory page from a block\textquotesingle{}s metadata. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a99051f1c2b6af9de76a35dc7546fe60c}{NEXT\+\_\+\+META\+\_\+\+BLOCK\+\_\+\+BY\+\_\+\+SIZE}}(block\+\_\+meta\+\_\+data\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Macro to retrieve the metadata of the next block based on the current block\textquotesingle{}s size. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_ac866fe97df08a8d286eafb8243cd63da}{NEXT\+\_\+\+META\+\_\+\+BLOCK}}(block\+\_\+meta\+\_\+data\+\_\+ptr)~((block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$next\+\_\+block)
\begin{DoxyCompactList}\small\item\em Macro to get the pointer to the next metadata block. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a3be8c5743e0cd0d83dc3b7802cbbe2fc}{PREV\+\_\+\+META\+\_\+\+BLOCK}}(block\+\_\+meta\+\_\+data\+\_\+ptr)~((block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$prev\+\_\+block)
\begin{DoxyCompactList}\small\item\em Macro to get the pointer to the previous metadata block. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a4cc1ec88cf052995c8c09a4cc9daf886}{MARK\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+EMPTY}}(vm\+\_\+page\+\_\+t\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Macro to mark a virtual memory page as empty. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_add6df20638bfeb770280984d1a88dfe6}{mm\+\_\+bind\+\_\+blocks\+\_\+for\+\_\+allocation}}(allocated\+\_\+meta\+\_\+block,  free\+\_\+meta\+\_\+block)
\begin{DoxyCompactList}\small\item\em Binds metadata blocks for memory allocation. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{memory__manager_8h_a8ddc0f810ab01f3747ae4793557a746b}{MAX\+\_\+\+PAGE\+\_\+\+ALLOCATABLE\+\_\+\+MEMORY}}(units)~  (\mbox{\hyperlink{group__VMPage_gae68e468ad150ea915ed9a3b9d899e9df}{mm\+\_\+max\+\_\+page\+\_\+allocatable\+\_\+memory}}(units))
\begin{DoxyCompactList}\small\item\em Macro to calculate the maximum allocatable memory for a given number of units. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \mbox{\hyperlink{structblock__meta__data__}{block\+\_\+meta\+\_\+data\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Structure representing metadata for a memory block. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{structvm__page__}{vm\+\_\+page\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Structure representing a virtual memory page. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{structvm__page__family__}{vm\+\_\+page\+\_\+family\+\_\+}} \mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Structure representing a page family in virtual memory. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{structvm__page__for__families__}{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a0cf10cad96e10ff9160b976e509f9462}{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Structure representing a virtual memory page containing families of memory structures. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}{vm\+\_\+bool\+\_\+t}} \{ \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24}{MM\+\_\+\+FALSE}} = 0
, \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556}{MM\+\_\+\+TRUE}} = 1
 \}
\begin{DoxyCompactList}\small\item\em Represents a boolean value. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{memory__manager_8h_aa604b0781f01e3696274d24e45a62ff2}{GLTHREAD\+\_\+\+TO\+\_\+\+STRUCT}} (glthread\+\_\+to\+\_\+block\+\_\+meta\+\_\+data, \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}}, priority\+\_\+thread\+\_\+glue, glthread\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Macro to declare a conversion function for converting a glthread\+\_\+t structure to a user-\/defined structure pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{group__VMPage_gacf4906c4a2cd80f10a570cc1c7411111}{allocate\+\_\+vm\+\_\+page}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family)
\begin{DoxyCompactList}\small\item\em Allocates a new virtual memory page for a given page family. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__VMPage_ga3c0f19fa657602a76893a7f53e9f5222}{mm\+\_\+vm\+\_\+page\+\_\+delete\+\_\+and\+\_\+free}} (\mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page)
\begin{DoxyCompactList}\small\item\em Deletes and frees a virtual memory page. \end{DoxyCompactList}\item 
\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{group__MemoryManagement_gab9910db7228c29ee672139e284cd6cec}{lookup\+\_\+page\+\_\+family\+\_\+by\+\_\+name}} (char \texorpdfstring{$\ast$}{*}struct\+\_\+name)
\begin{DoxyCompactList}\small\item\em Looks up a page family by its name. \end{DoxyCompactList}\item 
\mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}{vm\+\_\+bool\+\_\+t}} \mbox{\hyperlink{group__VMPage_ga38d0ee21c7b3b9b22289786fd969be46}{mm\+\_\+is\+\_\+vm\+\_\+page\+\_\+empty}} (\mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page)
\begin{DoxyCompactList}\small\item\em Checks if a virtual memory page is empty. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{memory__manager_8h_aa72156192006fd76902b0616def7db4d}{mm\+\_\+add\+\_\+free\+\_\+block\+\_\+meta\+\_\+data\+\_\+to\+\_\+free\+\_\+block\+\_\+list}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family, \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}free\+\_\+block)
\begin{DoxyCompactList}\small\item\em Add a free block\textquotesingle{}s metadata to the free block list of a virtual memory page family. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{memory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68}{mm\+\_\+print\+\_\+vm\+\_\+page\+\_\+details}} (\mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page)
\begin{DoxyCompactList}\small\item\em Prints details of a virtual memory page. \end{DoxyCompactList}\item 
static void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{memory__manager_8h_a8b6e564655ddbbb3147b2d28ee398e5c}{mm\+\_\+get\+\_\+new\+\_\+vm\+\_\+page\+\_\+from\+\_\+kernel}} (int units)
\begin{DoxyCompactList}\small\item\em Allocates a new virtual memory page from the kernel. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{memory__manager_8h_ab7ac1212082ab9c61aab19e76696d9ec}{mm\+\_\+return\+\_\+vm\+\_\+page\+\_\+to\+\_\+kernel}} (void \texorpdfstring{$\ast$}{*}vm\+\_\+page, int units)
\begin{DoxyCompactList}\small\item\em Returns a virtual memory page to the kernel. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{memory__manager_8h_a8b1f18097a67a303b6182eaf288b64f9}{mm\+\_\+union\+\_\+free\+\_\+blocks}} (\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}first, \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}second)
\begin{DoxyCompactList}\small\item\em Merges two contiguous free memory blocks. \end{DoxyCompactList}\item 
static uint32\+\_\+t \mbox{\hyperlink{memory__manager_8h_ae68e468ad150ea915ed9a3b9d899e9df}{mm\+\_\+max\+\_\+page\+\_\+allocatable\+\_\+memory}} (int units)
\begin{DoxyCompactList}\small\item\em Calculates the maximum allocatable memory within a virtual memory page. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{memory__manager_8h_a5987bb26622d19dcd8ecfd1416a7f3c6}{free\+\_\+blocks\+\_\+comparison\+\_\+function}} (void \texorpdfstring{$\ast$}{*}\+\_\+block\+\_\+meta\+\_\+data1, void \texorpdfstring{$\ast$}{*}\+\_\+block\+\_\+meta\+\_\+data2)
\begin{DoxyCompactList}\small\item\em Comparison function for sorting free blocks by block size. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{memory__manager_8h_a28b2162ebaea314c420ca44e29fb9d44}{mm\+\_\+get\+\_\+biggest\+\_\+free\+\_\+block\+\_\+page\+\_\+family}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family)
\begin{DoxyCompactList}\small\item\em Retrieves the metadata of the biggest free memory block within a given virtual memory page family. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}{vm\+\_\+bool\+\_\+t}} \mbox{\hyperlink{memory__manager_8h_ab335253cb154c4adb2beb3cea638fb3c}{mm\+\_\+split\+\_\+free\+\_\+data\+\_\+block\+\_\+for\+\_\+allocation}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family, \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}block\+\_\+meta\+\_\+data, uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Splits a free data block to allocate a portion of it for memory allocation. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{memory__manager_8h_a464ebae83b876a0ebb252e793e296fe9}{mm\+\_\+allocate\+\_\+free\+\_\+data\+\_\+block}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family, uint32\+\_\+t req\+\_\+size)
\begin{DoxyCompactList}\small\item\em Allocates a free data block from the specified page family. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{memory__manager_8h_acf3ff2e7438d4ae2c531e8851b7270e8}{mm\+\_\+family\+\_\+new\+\_\+page\+\_\+add}} (\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}vm\+\_\+page\+\_\+family)
\begin{DoxyCompactList}\small\item\em Adds a new virtual memory page to the specified page family. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{memory__manager_8h_a3635ea0217471faffe42b0c91c4bcc42}{mm\+\_\+get\+\_\+hard\+\_\+internal\+\_\+memory\+\_\+frag\+\_\+size}} (\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}first, \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}second)
\begin{DoxyCompactList}\small\item\em Calculates the size of hard internal memory fragmentation between two memory blocks. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{memory__manager_8h_a2250996fd809506caef0a6e61b6faebb}{mm\+\_\+free\+\_\+blocks}} (\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}to\+\_\+be\+\_\+free\+\_\+block)
\begin{DoxyCompactList}\small\item\em Frees a memory block and performs merging if necessary. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header file for the Memory Manager module. 

This file provides declarations for structures, macros, and functions used in the Memory Manager module. The Memory Manager is responsible for managing memory allocation and deallocation, including virtual memory page management, block metadata handling, and allocation algorithms. 

\doxysubsection{Macro Definition Documentation}
\Hypertarget{memory__manager_8h_ac15f4fa9d6b78fc0ff539a7d1d4b64d2}\label{memory__manager_8h_ac15f4fa9d6b78fc0ff539a7d1d4b64d2} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_PAGE\_FAMILIES\_BEGIN@{ITERATE\_PAGE\_FAMILIES\_BEGIN}}
\index{ITERATE\_PAGE\_FAMILIES\_BEGIN@{ITERATE\_PAGE\_FAMILIES\_BEGIN}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_PAGE\_FAMILIES\_BEGIN}{ITERATE\_PAGE\_FAMILIES\_BEGIN}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+BEGIN(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ uint32\_t\ \_count\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ for\ (curr\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ (\mbox{\hyperlink{structvm__page__family__}{vm\_page\_family\_t}}\ *)\&vm\_page\_for\_families\_ptr-\/>vm\_page\_family[0];\ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ curr-\/>struct\_size\ \&\&\ \_count\ <\ \mbox{\hyperlink{memory__manager_8h_a1144c25dd2f4ee38d1825adf4a316a27}{MAX\_FAMILIES\_PER\_VM\_PAGE}};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ curr++,\ \_count++)\ \{}

\end{DoxyCode}


Macro for beginning iteration over page families. 

This macro is used to begin iteration over page families stored within a virtual memory page. It initializes a loop for iterating over page families, using the provided pointers.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr} & Pointer to the virtual memory page for families. \\
\hline
{\em curr} & Pointer to the current page family being iterated.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This macro is typically used in conjunction with {\ttfamily ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+END} to iterate over page families stored within a virtual memory page. The loop continues until all page families have been iterated or the maximum number of families per page is reached.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
This macro assumes that {\ttfamily vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr} points to a valid virtual memory page structure containing page families, and {\ttfamily curr} is a valid pointer to iterate over these families. Improper usage may result in undefined behavior.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\doxylink{memory__manager_8h_ade62c3641f42fba45136e760112aca9c}{ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+END} 
\end{DoxySeeAlso}
\Hypertarget{memory__manager_8h_ade62c3641f42fba45136e760112aca9c}\label{memory__manager_8h_ade62c3641f42fba45136e760112aca9c} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_PAGE\_FAMILIES\_END@{ITERATE\_PAGE\_FAMILIES\_END}}
\index{ITERATE\_PAGE\_FAMILIES\_END@{ITERATE\_PAGE\_FAMILIES\_END}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_PAGE\_FAMILIES\_END}{ITERATE\_PAGE\_FAMILIES\_END}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+END(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \}}

\end{DoxyCode}


Macro marking the end of iteration over families within a virtual memory page. 

This macro is used to mark the end of iteration over families within a virtual memory page, which was started with the {\ttfamily ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+BEGIN} macro. It concludes the loop for iterating over page families.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+for\+\_\+families\+\_\+ptr} & Pointer to the virtual memory page for families. \\
\hline
{\em curr} & Pointer to the current family being iterated.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This macro should be used in conjunction with {\ttfamily ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+BEGIN} to properly mark the end of the iteration loop over page families within a virtual memory page.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
The loop for iterating over families within a virtual memory page should be enclosed within curly braces {\ttfamily \{\}} to ensure proper scoping of loop variables and statements. Improper usage of this macro may lead to compilation errors or unexpected behavior.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\doxylink{memory__manager_8h_ac15f4fa9d6b78fc0ff539a7d1d4b64d2}{ITERATE\+\_\+\+PAGE\+\_\+\+FAMILIES\+\_\+\+BEGIN} 
\end{DoxySeeAlso}
\Hypertarget{memory__manager_8h_ac163a8510af79f4a2e157f664a0a73cc}\label{memory__manager_8h_ac163a8510af79f4a2e157f664a0a73cc} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN@{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN}}
\index{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN@{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN}{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_BEGIN}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+BEGIN(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{do}\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ curr\ =\ \&(vm\_page\_ptr-\/>block\_meta\_data);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structblock__meta__data__}{block\_meta\_data\_t}}\ *next\ =\ NULL;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ for\ (;\ curr\ !=\ NULL;\ curr\ =\ next)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ next\ =\ \mbox{\hyperlink{memory__manager_8h_ac866fe97df08a8d286eafb8243cd63da}{NEXT\_META\_BLOCK}}(curr);}

\end{DoxyCode}


Macro to begin iteration over all memory blocks within a virtual memory page. 

This macro initializes the iteration process over all memory blocks within a given virtual memory page.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+ptr} & Pointer to the virtual memory page. \\
\hline
{\em curr} & Pointer to hold the current memory block during iteration.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This macro is typically used in memory management systems to iterate over all memory blocks within a virtual memory page. It sets up a loop that traverses through the metadata blocks of each memory block within the page. The iteration begins with the metadata block of the first memory block in the page. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a54793f38cfc42b2f461e3b198efa9a1e}\label{memory__manager_8h_a54793f38cfc42b2f461e3b198efa9a1e} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END@{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END}}
\index{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END@{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END}{ITERATE\_VM\_PAGE\_ALL\_BLOCKS\_END}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+END(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ while\ (0)}

\end{DoxyCode}


Macro to end iteration over all memory blocks within a virtual memory page. 

This macro marks the end of the iteration process over all memory blocks within a virtual memory page.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+ptr} & Pointer to the virtual memory page. \\
\hline
{\em curr} & Pointer holding the current memory block during iteration.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This macro is used in conjunction with ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+BEGIN macro to define the end of the iteration loop. It completes the loop setup by ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+ALL\+\_\+\+BLOCKS\+\_\+\+BEGIN, ensuring proper termination of the loop. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_ac631f611777465204532dc3ab987b332}\label{memory__manager_8h_ac631f611777465204532dc3ab987b332} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_VM\_PAGE\_BEGIN@{ITERATE\_VM\_PAGE\_BEGIN}}
\index{ITERATE\_VM\_PAGE\_BEGIN@{ITERATE\_VM\_PAGE\_BEGIN}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_VM\_PAGE\_BEGIN}{ITERATE\_VM\_PAGE\_BEGIN}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+BEGIN(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+family\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ curr\ =\ (vm\_page\_family\_ptr)-\/>first\_page;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structvm__page__}{vm\_page\_t}}\ *next\ =\ NULL;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ for\ (;\ curr\ !=\ NULL;\ curr\ =\ next)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ next\ =\ curr-\/>\mbox{\hyperlink{structvm__page___a87995cd55301183d3d7c94ae9cfc0bfb}{next}};}

\end{DoxyCode}


Macro to iterate over virtual memory pages beginning from the first page of a page family. 

This macro allows for iterating over virtual memory pages starting from the first page of a specified page family.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family\+\_\+ptr} & Pointer to the page family containing the first page. \\
\hline
{\em curr} & Pointer variable to hold the current virtual memory page during iteration. \\
\hline
\end{DoxyParams}
\Hypertarget{memory__manager_8h_a596be76ddc13d22fa0fe655e5dd58931}\label{memory__manager_8h_a596be76ddc13d22fa0fe655e5dd58931} 
\index{memory\_manager.h@{memory\_manager.h}!ITERATE\_VM\_PAGE\_END@{ITERATE\_VM\_PAGE\_END}}
\index{ITERATE\_VM\_PAGE\_END@{ITERATE\_VM\_PAGE\_END}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{ITERATE\_VM\_PAGE\_END}{ITERATE\_VM\_PAGE\_END}}
{\footnotesize\ttfamily \#define ITERATE\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+END(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+family\+\_\+ptr,  }\item[{}]{curr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \}}

\end{DoxyCode}


Macro marking the end of the iteration over virtual memory pages. 

This macro marks the end of the iteration over virtual memory pages.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family\+\_\+ptr} & Pointer to the page family containing the first page. \\
\hline
{\em curr} & Pointer variable holding the current virtual memory page. \\
\hline
\end{DoxyParams}
\Hypertarget{memory__manager_8h_a4cc1ec88cf052995c8c09a4cc9daf886}\label{memory__manager_8h_a4cc1ec88cf052995c8c09a4cc9daf886} 
\index{memory\_manager.h@{memory\_manager.h}!MARK\_VM\_PAGE\_EMPTY@{MARK\_VM\_PAGE\_EMPTY}}
\index{MARK\_VM\_PAGE\_EMPTY@{MARK\_VM\_PAGE\_EMPTY}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MARK\_VM\_PAGE\_EMPTY}{MARK\_VM\_PAGE\_EMPTY}}
{\footnotesize\ttfamily \#define MARK\+\_\+\+VM\+\_\+\+PAGE\+\_\+\+EMPTY(\begin{DoxyParamCaption}\item[{}]{vm\+\_\+page\+\_\+t\+\_\+ptr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{do}\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ (vm\_page\_t\_ptr)-\/>block\_meta\_data.next\_block\ =\ NULL;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ (vm\_page\_t\_ptr)-\/>block\_meta\_data.prev\_block\ =\ NULL;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ (vm\_page\_t\_ptr)-\/>block\_meta\_data.is\_free\ =\ \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556}{MM\_TRUE}};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \}\ \textcolor{keywordflow}{while}\ (0)}

\end{DoxyCode}


Macro to mark a virtual memory page as empty. 

This macro is heavily documented to provide detailed information about its purpose, usage, and behavior.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+t\+\_\+ptr} & Pointer to the virtual memory page to be marked as empty.\\
\hline
\end{DoxyParams}
This macro is used to reset the state of a virtual memory page, indicating that it contains no allocated memory blocks and is available for reuse. It operates by modifying the metadata associated with the memory blocks within the page.

The macro takes a single parameter\+:
\begin{DoxyItemize}
\item {\ttfamily vm\+\_\+page\+\_\+t\+\_\+ptr\+:} Pointer to the virtual memory page to be marked as empty.
\end{DoxyItemize}

The macro does the following\+:
\begin{DoxyItemize}
\item Sets the \textquotesingle{}next\+\_\+block\textquotesingle{} and \textquotesingle{}prev\+\_\+block\textquotesingle{} pointers of the block metadata to NULL, indicating that the page does not have any neighboring blocks.
\item Sets the \textquotesingle{}is\+\_\+free\textquotesingle{} flag of the block metadata to MM\+\_\+\+TRUE, indicating that the page is free and available for allocation.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
This macro should be used judiciously and only when it is certain that the virtual memory page is not in use and can be safely reset. Incorrect usage may lead to memory corruption or undefined behavior.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
It is important to ensure that the \textquotesingle{}vm\+\_\+page\+\_\+t\+\_\+ptr\textquotesingle{} parameter is a valid pointer to a virtual memory page structure. Passing invalid or uninitialized pointers may result in undefined behavior.
\end{DoxyWarning}
\begin{DoxyRemark}{Remarks}
This macro is typically used in memory management systems as part of memory recycling and allocation routines. It helps maintain memory hygiene by properly managing the state of virtual memory pages. 
\end{DoxyRemark}
\Hypertarget{memory__manager_8h_a1144c25dd2f4ee38d1825adf4a316a27}\label{memory__manager_8h_a1144c25dd2f4ee38d1825adf4a316a27} 
\index{memory\_manager.h@{memory\_manager.h}!MAX\_FAMILIES\_PER\_VM\_PAGE@{MAX\_FAMILIES\_PER\_VM\_PAGE}}
\index{MAX\_FAMILIES\_PER\_VM\_PAGE@{MAX\_FAMILIES\_PER\_VM\_PAGE}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MAX\_FAMILIES\_PER\_VM\_PAGE}{MAX\_FAMILIES\_PER\_VM\_PAGE}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+FAMILIES\+\_\+\+PER\+\_\+\+VM\+\_\+\+PAGE}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ (\mbox{\hyperlink{memory__manager_8c_a556910a8e507af29f88df82ead01d5af}{SYSTEM\_PAGE\_SIZE}}\ -\/\ \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct\ }\mbox{\hyperlink{structvm__page__for__families__}{vm\_page\_for\_families\_}}\ *))\ /\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ sizeof(\textcolor{keyword}{struct}\ \mbox{\hyperlink{structvm__page__family__}{vm\_page\_family\_}})}

\end{DoxyCode}


Maximum number of families that can be stored in a single virtual memory page. 

This macro calculates the maximum number of families that can be stored in a single virtual memory page based on the system page size and the sizes of the {\ttfamily vm\+\_\+page\+\_\+for\+\_\+families\+\_\+t} and {\ttfamily vm\+\_\+page\+\_\+family\+\_\+t} structures. It accounts for the space occupied by the {\ttfamily next} pointer in {\ttfamily vm\+\_\+page\+\_\+for\+\_\+families\+\_\+t}.

\begin{DoxyNote}{Note}
The calculation subtracts the size of the {\ttfamily next} pointer from the total system page size, and then divides the remaining size by the size of a single {\ttfamily vm\+\_\+page\+\_\+family\+\_\+t} structure.

This macro is useful for determining the maximum capacity of a virtual memory page for managing families of memory structures. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a8ddc0f810ab01f3747ae4793557a746b}\label{memory__manager_8h_a8ddc0f810ab01f3747ae4793557a746b} 
\index{memory\_manager.h@{memory\_manager.h}!MAX\_PAGE\_ALLOCATABLE\_MEMORY@{MAX\_PAGE\_ALLOCATABLE\_MEMORY}}
\index{MAX\_PAGE\_ALLOCATABLE\_MEMORY@{MAX\_PAGE\_ALLOCATABLE\_MEMORY}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MAX\_PAGE\_ALLOCATABLE\_MEMORY}{MAX\_PAGE\_ALLOCATABLE\_MEMORY}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+PAGE\+\_\+\+ALLOCATABLE\+\_\+\+MEMORY(\begin{DoxyParamCaption}\item[{}]{units }\end{DoxyParamCaption})~  (\mbox{\hyperlink{group__VMPage_gae68e468ad150ea915ed9a3b9d899e9df}{mm\+\_\+max\+\_\+page\+\_\+allocatable\+\_\+memory}}(units))}



Macro to calculate the maximum allocatable memory for a given number of units. 

This macro calculates the maximum allocatable memory for a specified number of units based on the system page size and the offset of the virtual memory page structure.


\begin{DoxyParams}{Parameters}
{\em units} & Number of units for which memory allocation is requested. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Maximum allocatable memory in bytes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This macro is typically used to determine the maximum amount of memory that can be allocated for a given number of units, considering system page constraints and structure offsets within the virtual memory page. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a56d7beb47f6bbf896e6f21fb09c73ec5}\label{memory__manager_8h_a56d7beb47f6bbf896e6f21fb09c73ec5} 
\index{memory\_manager.h@{memory\_manager.h}!MAX\_STRUCT\_NAME\_LEN@{MAX\_STRUCT\_NAME\_LEN}}
\index{MAX\_STRUCT\_NAME\_LEN@{MAX\_STRUCT\_NAME\_LEN}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MAX\_STRUCT\_NAME\_LEN}{MAX\_STRUCT\_NAME\_LEN}}
{\footnotesize\ttfamily \#define MAX\+\_\+\+STRUCT\+\_\+\+NAME\+\_\+\+LEN~50}

\Hypertarget{memory__manager_8h_add6df20638bfeb770280984d1a88dfe6}\label{memory__manager_8h_add6df20638bfeb770280984d1a88dfe6} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_bind\_blocks\_for\_allocation@{mm\_bind\_blocks\_for\_allocation}}
\index{mm\_bind\_blocks\_for\_allocation@{mm\_bind\_blocks\_for\_allocation}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_bind\_blocks\_for\_allocation}{mm\_bind\_blocks\_for\_allocation}}
{\footnotesize\ttfamily \#define mm\+\_\+bind\+\_\+blocks\+\_\+for\+\_\+allocation(\begin{DoxyParamCaption}\item[{}]{allocated\+\_\+meta\+\_\+block,  }\item[{}]{free\+\_\+meta\+\_\+block }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ free\_meta\_block-\/>prev\_block\ =\ allocated\_meta\_block;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ free\_meta\_block-\/>next\_block\ =\ allocated\_meta\_block-\/>next\_block;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ allocated\_meta\_block-\/>next\_block\ =\ free\_meta\_block;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ if\ (free\_meta\_block-\/>next\_block)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ free\_meta\_block-\/>next\_block-\/>prev\_block\ =\ free\_meta\_block}

\end{DoxyCode}


Binds metadata blocks for memory allocation. 

This macro is used to bind metadata blocks for memory allocation. It updates the pointers of the allocated and free blocks to maintain the integrity of the memory management system.


\begin{DoxyParams}{Parameters}
{\em allocated\+\_\+meta\+\_\+block} & Pointer to the metadata block of the allocated memory. \\
\hline
{\em free\+\_\+meta\+\_\+block} & Pointer to the metadata block of the free memory.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This macro is typically used in memory management systems to properly link allocated and free memory blocks. It ensures correct traversal and management of memory blocks, maintaining the coherence of the memory allocation process. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a8b33c3f061b53c0229ff71ef0b291595}\label{memory__manager_8h_a8b33c3f061b53c0229ff71ef0b291595} 
\index{memory\_manager.h@{memory\_manager.h}!MM\_GET\_PAGE\_FROM\_META\_BLOCK@{MM\_GET\_PAGE\_FROM\_META\_BLOCK}}
\index{MM\_GET\_PAGE\_FROM\_META\_BLOCK@{MM\_GET\_PAGE\_FROM\_META\_BLOCK}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MM\_GET\_PAGE\_FROM\_META\_BLOCK}{MM\_GET\_PAGE\_FROM\_META\_BLOCK}}
{\footnotesize\ttfamily \#define MM\+\_\+\+GET\+\_\+\+PAGE\+\_\+\+FROM\+\_\+\+META\+\_\+\+BLOCK(\begin{DoxyParamCaption}\item[{}]{block\+\_\+meta\+\_\+data\+\_\+ptr }\end{DoxyParamCaption})~  ((void \texorpdfstring{$\ast$}{*})((char \texorpdfstring{$\ast$}{*})(block\+\_\+meta\+\_\+data\+\_\+ptr) -\/ (block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$offset))}



Macro to retrieve the virtual memory page from a block\textquotesingle{}s metadata. 

This macro retrieves the virtual memory page associated with a given block\textquotesingle{}s metadata.


\begin{DoxyParams}{Parameters}
{\em block\+\_\+meta\+\_\+data\+\_\+ptr} & Pointer to the block\textquotesingle{}s metadata. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the virtual memory page. 
\end{DoxyReturn}
\Hypertarget{memory__manager_8h_a7e33ad2337bb751f178af9eebc45a84d}\label{memory__manager_8h_a7e33ad2337bb751f178af9eebc45a84d} 
\index{memory\_manager.h@{memory\_manager.h}!MM\_MAX\_STRUCT\_NAME@{MM\_MAX\_STRUCT\_NAME}}
\index{MM\_MAX\_STRUCT\_NAME@{MM\_MAX\_STRUCT\_NAME}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{MM\_MAX\_STRUCT\_NAME}{MM\_MAX\_STRUCT\_NAME}}
{\footnotesize\ttfamily \#define MM\+\_\+\+MAX\+\_\+\+STRUCT\+\_\+\+NAME~32}

\texorpdfstring{$<$}{<} System includes \texorpdfstring{$<$}{<} External includes \Hypertarget{memory__manager_8h_ac866fe97df08a8d286eafb8243cd63da}\label{memory__manager_8h_ac866fe97df08a8d286eafb8243cd63da} 
\index{memory\_manager.h@{memory\_manager.h}!NEXT\_META\_BLOCK@{NEXT\_META\_BLOCK}}
\index{NEXT\_META\_BLOCK@{NEXT\_META\_BLOCK}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{NEXT\_META\_BLOCK}{NEXT\_META\_BLOCK}}
{\footnotesize\ttfamily \#define NEXT\+\_\+\+META\+\_\+\+BLOCK(\begin{DoxyParamCaption}\item[{}]{block\+\_\+meta\+\_\+data\+\_\+ptr }\end{DoxyParamCaption})~((block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$next\+\_\+block)}



Macro to get the pointer to the next metadata block. 

This macro is used to obtain the pointer to the next metadata block given a pointer to the current metadata block.


\begin{DoxyParams}{Parameters}
{\em block\+\_\+meta\+\_\+data\+\_\+ptr} & Pointer to the current metadata block.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the next metadata block.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This macro is typically used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the metadata blocks linked list, enabling operations such as coalescing adjacent free memory blocks or iterating over allocated memory blocks. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a99051f1c2b6af9de76a35dc7546fe60c}\label{memory__manager_8h_a99051f1c2b6af9de76a35dc7546fe60c} 
\index{memory\_manager.h@{memory\_manager.h}!NEXT\_META\_BLOCK\_BY\_SIZE@{NEXT\_META\_BLOCK\_BY\_SIZE}}
\index{NEXT\_META\_BLOCK\_BY\_SIZE@{NEXT\_META\_BLOCK\_BY\_SIZE}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{NEXT\_META\_BLOCK\_BY\_SIZE}{NEXT\_META\_BLOCK\_BY\_SIZE}}
{\footnotesize\ttfamily \#define NEXT\+\_\+\+META\+\_\+\+BLOCK\+\_\+\+BY\+\_\+\+SIZE(\begin{DoxyParamCaption}\item[{}]{block\+\_\+meta\+\_\+data\+\_\+ptr }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ ((\mbox{\hyperlink{structblock__meta__data__}{block\_meta\_data\_t}}\ *)((\textcolor{keywordtype}{char}\ *)(block\_meta\_data\_ptr\ +\ 1)\ +\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (block\_meta\_data\_ptr)-\/>block\_size))}

\end{DoxyCode}


Macro to retrieve the metadata of the next block based on the current block\textquotesingle{}s size. 

This macro calculates the pointer to the metadata of the next block by adding the size of the current block to the pointer to the current block\textquotesingle{}s metadata.


\begin{DoxyParams}{Parameters}
{\em block\+\_\+meta\+\_\+data\+\_\+ptr} & Pointer to the current block\textquotesingle{}s metadata. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the metadata of the next block.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This macro is commonly used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the memory blocks, enabling operations such as coalescing adjacent free memory blocks or iterating over allocated memory blocks.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
The behavior of this macro depends on the assumption that the next block starts immediately after the current block in memory. Ensure that the memory layout and block sizes are correctly managed to avoid undefined behavior. 
\end{DoxyWarning}
\Hypertarget{memory__manager_8h_a53981175c7d4dcad912920a3ab7626ae}\label{memory__manager_8h_a53981175c7d4dcad912920a3ab7626ae} 
\index{memory\_manager.h@{memory\_manager.h}!offset\_of@{offset\_of}}
\index{offset\_of@{offset\_of}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{offset\_of}{offset\_of}}
{\footnotesize\ttfamily \#define offset\+\_\+of(\begin{DoxyParamCaption}\item[{}]{container\+\_\+structure,  }\item[{}]{field\+\_\+name }\end{DoxyParamCaption})~  ((size\+\_\+t)(\&((container\+\_\+structure \texorpdfstring{$\ast$}{*})0)-\/$>$field\+\_\+name))}



Macro to calculate the offset of a field within a structure. 

This macro calculates the byte offset of a specified field within a structure. It is often used in low-\/level programming to access structure members at specific memory locations.


\begin{DoxyParams}{Parameters}
{\em container\+\_\+structure} & The name of the structure containing the field. \\
\hline
{\em field\+\_\+name} & The name of the field whose offset is being calculated.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte offset of the field within the structure.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This macro uses the pointer arithmetic to calculate the offset. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a3be8c5743e0cd0d83dc3b7802cbbe2fc}\label{memory__manager_8h_a3be8c5743e0cd0d83dc3b7802cbbe2fc} 
\index{memory\_manager.h@{memory\_manager.h}!PREV\_META\_BLOCK@{PREV\_META\_BLOCK}}
\index{PREV\_META\_BLOCK@{PREV\_META\_BLOCK}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{PREV\_META\_BLOCK}{PREV\_META\_BLOCK}}
{\footnotesize\ttfamily \#define PREV\+\_\+\+META\+\_\+\+BLOCK(\begin{DoxyParamCaption}\item[{}]{block\+\_\+meta\+\_\+data\+\_\+ptr }\end{DoxyParamCaption})~((block\+\_\+meta\+\_\+data\+\_\+ptr)-\/$>$prev\+\_\+block)}



Macro to get the pointer to the previous metadata block. 

This macro is used to obtain the pointer to the previous metadata block given a pointer to the current metadata block.


\begin{DoxyParams}{Parameters}
{\em block\+\_\+meta\+\_\+data\+\_\+ptr} & Pointer to the current metadata block.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the previous metadata block.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This macro is typically used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the metadata blocks linked list, allowing operations such as merging adjacent free memory blocks or finding neighboring blocks. 
\end{DoxyNote}


\doxysubsection{Typedef Documentation}
\Hypertarget{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}\label{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f} 
\index{memory\_manager.h@{memory\_manager.h}!block\_meta\_data\_t@{block\_meta\_data\_t}}
\index{block\_meta\_data\_t@{block\_meta\_data\_t}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{block\_meta\_data\_t}{block\_meta\_data\_t}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structblock__meta__data__}{block\+\_\+meta\+\_\+data\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}}}



Structure representing metadata for a memory block. 

The {\ttfamily block\+\_\+meta\+\_\+data\+\_\+t} structure represents metadata for a memory block. It includes information such as whether the block is free or allocated, its size, pointers to the previous and next blocks (if applicable), and the offset within the memory region. \Hypertarget{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}\label{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8} 
\index{memory\_manager.h@{memory\_manager.h}!vm\_page\_family\_t@{vm\_page\_family\_t}}
\index{vm\_page\_family\_t@{vm\_page\_family\_t}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{vm\_page\_family\_t}{vm\_page\_family\_t}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structvm__page__family__}{vm\+\_\+page\+\_\+family\+\_\+}} \mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}}}



Structure representing a page family in virtual memory. 

This structure maintains information about a page family in virtual memory, including the name of the structure, its size, a pointer to the most recent virtual memory page in use, and a priority list of free memory blocks. \Hypertarget{memory__manager_8h_a0cf10cad96e10ff9160b976e509f9462}\label{memory__manager_8h_a0cf10cad96e10ff9160b976e509f9462} 
\index{memory\_manager.h@{memory\_manager.h}!vm\_page\_for\_families\_t@{vm\_page\_for\_families\_t}}
\index{vm\_page\_for\_families\_t@{vm\_page\_for\_families\_t}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{vm\_page\_for\_families\_t}{vm\_page\_for\_families\_t}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structvm__page__for__families__}{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a0cf10cad96e10ff9160b976e509f9462}{vm\+\_\+page\+\_\+for\+\_\+families\+\_\+t}}}



Structure representing a virtual memory page containing families of memory structures. 

\Hypertarget{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}\label{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868} 
\index{memory\_manager.h@{memory\_manager.h}!vm\_page\_t@{vm\_page\_t}}
\index{vm\_page\_t@{vm\_page\_t}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{vm\_page\_t}{vm\_page\_t}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structvm__page__}{vm\+\_\+page\+\_\+}} \mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}}}



Structure representing a virtual memory page. 

This structure represents a virtual memory page used in memory management systems. It contains metadata for managing memory blocks within the page, as well as the actual memory region allocated for storing data blocks. 

\doxysubsection{Enumeration Type Documentation}
\Hypertarget{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}\label{memory__manager_8h_a8137dde168b63da6dc080c3e41660743} 
\index{memory\_manager.h@{memory\_manager.h}!vm\_bool\_t@{vm\_bool\_t}}
\index{vm\_bool\_t@{vm\_bool\_t}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{vm\_bool\_t}{vm\_bool\_t}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}{vm\+\_\+bool\+\_\+t}}}



Represents a boolean value. 

The {\ttfamily vm\+\_\+bool\+\_\+t} type represents a boolean value, which can have one of two states\+: {\ttfamily VM\+\_\+\+TRUE} or {\ttfamily VM\+\_\+\+FALSE}. It is used to store boolean values in the program. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{MM\_FALSE@{MM\_FALSE}!memory\_manager.h@{memory\_manager.h}}\index{memory\_manager.h@{memory\_manager.h}!MM\_FALSE@{MM\_FALSE}}}\Hypertarget{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24}\label{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24} 
MM\+\_\+\+FALSE&Represents the false state. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MM\_TRUE@{MM\_TRUE}!memory\_manager.h@{memory\_manager.h}}\index{memory\_manager.h@{memory\_manager.h}!MM\_TRUE@{MM\_TRUE}}}\Hypertarget{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556}\label{memory__manager_8h_a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556} 
MM\+\_\+\+TRUE&Represents the true state. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\Hypertarget{memory__manager_8h_a5987bb26622d19dcd8ecfd1416a7f3c6}\label{memory__manager_8h_a5987bb26622d19dcd8ecfd1416a7f3c6} 
\index{memory\_manager.h@{memory\_manager.h}!free\_blocks\_comparison\_function@{free\_blocks\_comparison\_function}}
\index{free\_blocks\_comparison\_function@{free\_blocks\_comparison\_function}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{free\_blocks\_comparison\_function()}{free\_blocks\_comparison\_function()}}
{\footnotesize\ttfamily static int free\+\_\+blocks\+\_\+comparison\+\_\+function (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{\+\_\+block\+\_\+meta\+\_\+data1,  }\item[{void \texorpdfstring{$\ast$}{*}}]{\+\_\+block\+\_\+meta\+\_\+data2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Comparison function for sorting free blocks by block size. 

This function compares two block\+\_\+meta\+\_\+data\+\_\+t objects based on their block sizes. It is intended to be used as a comparison function for sorting free blocks in descending order of block size.


\begin{DoxyParams}{Parameters}
{\em \+\_\+block\+\_\+meta\+\_\+data1} & Pointer to the first block\+\_\+meta\+\_\+data\+\_\+t object. \\
\hline
{\em \+\_\+block\+\_\+meta\+\_\+data2} & Pointer to the second block\+\_\+meta\+\_\+data\+\_\+t object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An integer value representing the result of the comparison\+:
\begin{DoxyItemize}
\item If the block size of \+\_\+block\+\_\+meta\+\_\+data1 is greater than that of \+\_\+block\+\_\+meta\+\_\+data2, the function returns -\/1.
\item If the block size of \+\_\+block\+\_\+meta\+\_\+data1 is less than that of \+\_\+block\+\_\+meta\+\_\+data2, the function returns 1.
\item If the block sizes are equal, the function returns 0. 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{memory__manager_8h_aa604b0781f01e3696274d24e45a62ff2}\label{memory__manager_8h_aa604b0781f01e3696274d24e45a62ff2} 
\index{memory\_manager.h@{memory\_manager.h}!GLTHREAD\_TO\_STRUCT@{GLTHREAD\_TO\_STRUCT}}
\index{GLTHREAD\_TO\_STRUCT@{GLTHREAD\_TO\_STRUCT}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{GLTHREAD\_TO\_STRUCT()}{GLTHREAD\_TO\_STRUCT()}}
{\footnotesize\ttfamily GLTHREAD\+\_\+\+TO\+\_\+\+STRUCT (\begin{DoxyParamCaption}\item[{glthread\+\_\+to\+\_\+block\+\_\+meta\+\_\+data}]{,  }\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}}}]{,  }\item[{priority\+\_\+thread\+\_\+glue}]{,  }\item[{glthread\+\_\+ptr}]{ }\end{DoxyParamCaption})}



Macro to declare a conversion function for converting a glthread\+\_\+t structure to a user-\/defined structure pointer. 

This macro simplifies the process of declaring a conversion function that takes a glthread\+\_\+t pointer and returns a pointer to a user-\/defined structure. It is particularly useful when you have a glthread\+\_\+t structure embedded within a user-\/defined structure and need to access the user-\/defined data.


\begin{DoxyParams}{Parameters}
{\em fn\+\_\+name} & The name of the conversion function to be declared. \\
\hline
{\em struct\+\_\+type} & The type of the user-\/defined structure. \\
\hline
{\em glthread\+\_\+member} & The name of the glthread\+\_\+t member within the user-\/defined structure. \\
\hline
{\em glthread\+\_\+ptr} & The name of the glthread\+\_\+t pointer variable.\\
\hline
\end{DoxyParams}
Example usage\+: Suppose we have a user-\/defined structure named block\+\_\+meta\+\_\+data\+\_\+t that contains a glthread\+\_\+t member named priority\+\_\+thread\+\_\+glue. To declare a conversion function named glthread\+\_\+to\+\_\+block\+\_\+meta\+\_\+data to convert a glthread\+\_\+t pointer to a block\+\_\+meta\+\_\+data\+\_\+t pointer, we use the following declaration\+:

\doxylink{memory__manager_8h_aa604b0781f01e3696274d24e45a62ff2}{GLTHREAD\+\_\+\+TO\+\_\+\+STRUCT(glthread\+\_\+to\+\_\+block\+\_\+meta\+\_\+data, block\+\_\+meta\+\_\+data\+\_\+t,                    priority\+\_\+thread\+\_\+glue, glthread\+\_\+ptr)};

Now, we can use glthread\+\_\+to\+\_\+block\+\_\+meta\+\_\+data to convert glthread\+\_\+t pointers to block\+\_\+meta\+\_\+data\+\_\+t pointers and access the metadata associated with memory blocks. \Hypertarget{memory__manager_8h_aa72156192006fd76902b0616def7db4d}\label{memory__manager_8h_aa72156192006fd76902b0616def7db4d} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list@{mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list}}
\index{mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list@{mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list()}{mm\_add\_free\_block\_meta\_data\_to\_free\_block\_list()}}
{\footnotesize\ttfamily static void mm\+\_\+add\+\_\+free\+\_\+block\+\_\+meta\+\_\+data\+\_\+to\+\_\+free\+\_\+block\+\_\+list (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page\+\_\+family,  }\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{free\+\_\+block }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Add a free block\textquotesingle{}s metadata to the free block list of a virtual memory page family. 

This function adds the metadata of a free block to the free block list of a virtual memory page family. The block metadata is inserted into the free block list in descending order of block size, based on the comparison function {\ttfamily free\+\_\+blocks\+\_\+comparison\+\_\+function}.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family} & Pointer to the virtual memory page family to which the free block metadata will be added. \\
\hline
{\em free\+\_\+block} & Pointer to the block\+\_\+meta\+\_\+data\+\_\+t structure representing the metadata of the free block to be added to the free block list.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function assumes that the {\ttfamily is\+\_\+free} flag of the {\ttfamily free\+\_\+block} structure is set to MM\+\_\+\+TRUE. An assertion will trigger if this condition is not met. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a464ebae83b876a0ebb252e793e296fe9}\label{memory__manager_8h_a464ebae83b876a0ebb252e793e296fe9} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_allocate\_free\_data\_block@{mm\_allocate\_free\_data\_block}}
\index{mm\_allocate\_free\_data\_block@{mm\_allocate\_free\_data\_block}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_allocate\_free\_data\_block()}{mm\_allocate\_free\_data\_block()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} mm\+\_\+allocate\+\_\+free\+\_\+data\+\_\+block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page\+\_\+family,  }\item[{uint32\+\_\+t}]{req\+\_\+size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocates a free data block from the specified page family. 

This function attempts to allocate a free data block of the requested size from the specified page family. It first checks if there is a sufficiently large free block available within the page family. If not, it adds a new page to the page family to satisfy the allocation request. If successful, it splits the free block to allocate the requested memory and returns a pointer to the allocated block\textquotesingle{}s metadata.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family} & Pointer to the page family from which to allocate the data block. \\
\hline
{\em req\+\_\+size} & The size of the data block to allocate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the allocated block\textquotesingle{}s metadata if successful, or NULL if the allocation fails.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function assumes that the specified page family has been properly initialized and that the requested size is within the maximum allocatable memory per page. It utilizes the mm\+\_\+family\+\_\+new\+\_\+page\+\_\+add and mm\+\_\+split\+\_\+free\+\_\+data\+\_\+block\+\_\+for\+\_\+allocation functions to add new pages and split free blocks for allocation, respectively. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_acf3ff2e7438d4ae2c531e8851b7270e8}\label{memory__manager_8h_acf3ff2e7438d4ae2c531e8851b7270e8} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_family\_new\_page\_add@{mm\_family\_new\_page\_add}}
\index{mm\_family\_new\_page\_add@{mm\_family\_new\_page\_add}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_family\_new\_page\_add()}{mm\_family\_new\_page\_add()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*} mm\+\_\+family\+\_\+new\+\_\+page\+\_\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page\+\_\+family }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Adds a new virtual memory page to the specified page family. 

This function adds a new virtual memory page to the specified page family. It first allocates a new page using the allocate\+\_\+vm\+\_\+page function and then adds the page to the page family. Additionally, it treats the new page as one free block and adds its metadata to the free block list of the page family.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family} & Pointer to the page family to which the new page will be added.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the newly added virtual memory page if successful, or NULL if allocation fails.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function assumes that the page family has been properly initialized and that the allocate\+\_\+vm\+\_\+page function is available for allocating new pages. It also relies on the mm\+\_\+add\+\_\+free\+\_\+block\+\_\+meta\+\_\+data\+\_\+to\+\_\+free\+\_\+block\+\_\+list function to add the metadata of the new page to the free block list of the page family. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a2250996fd809506caef0a6e61b6faebb}\label{memory__manager_8h_a2250996fd809506caef0a6e61b6faebb} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_free\_blocks@{mm\_free\_blocks}}
\index{mm\_free\_blocks@{mm\_free\_blocks}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_free\_blocks()}{mm\_free\_blocks()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} mm\+\_\+free\+\_\+blocks (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{to\+\_\+be\+\_\+free\+\_\+block }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Frees a memory block and performs merging if necessary. 

This function frees a memory block represented by the given {\ttfamily to\+\_\+be\+\_\+free\+\_\+block} parameter. It also handles merging of adjacent free blocks if present.


\begin{DoxyParams}{Parameters}
{\em to\+\_\+be\+\_\+free\+\_\+block} & The block to be freed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the freed block or NULL if the hosting page becomes empty.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The function assumes that {\ttfamily to\+\_\+be\+\_\+free\+\_\+block} is not NULL and its is\+\_\+free flag is set to MM\+\_\+\+FALSE (indicating it\textquotesingle{}s not already free). MM\+\_\+\+H\+\_\+ 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a28b2162ebaea314c420ca44e29fb9d44}\label{memory__manager_8h_a28b2162ebaea314c420ca44e29fb9d44} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_get\_biggest\_free\_block\_page\_family@{mm\_get\_biggest\_free\_block\_page\_family}}
\index{mm\_get\_biggest\_free\_block\_page\_family@{mm\_get\_biggest\_free\_block\_page\_family}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_get\_biggest\_free\_block\_page\_family()}{mm\_get\_biggest\_free\_block\_page\_family()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*} mm\+\_\+get\+\_\+biggest\+\_\+free\+\_\+block\+\_\+page\+\_\+family (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page\+\_\+family }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Retrieves the metadata of the biggest free memory block within a given virtual memory page family. 

This function retrieves the metadata of the biggest free memory block within a specified virtual memory page family. It utilizes a priority list to maintain the biggest free block at the head of the list.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family} & Pointer to the virtual memory page family for which the biggest free block is to be retrieved.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the metadata of the biggest free memory block within the page family. If no such block exists (i.\+e., the priority list is empty), it returns NULL.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function is typically used in memory management systems to efficiently locate the largest available free block within a page family, which can then be used for memory allocation. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a3635ea0217471faffe42b0c91c4bcc42}\label{memory__manager_8h_a3635ea0217471faffe42b0c91c4bcc42} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_get\_hard\_internal\_memory\_frag\_size@{mm\_get\_hard\_internal\_memory\_frag\_size}}
\index{mm\_get\_hard\_internal\_memory\_frag\_size@{mm\_get\_hard\_internal\_memory\_frag\_size}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_get\_hard\_internal\_memory\_frag\_size()}{mm\_get\_hard\_internal\_memory\_frag\_size()}}
{\footnotesize\ttfamily static int mm\+\_\+get\+\_\+hard\+\_\+internal\+\_\+memory\+\_\+frag\+\_\+size (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{first,  }\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{second }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the size of hard internal memory fragmentation between two memory blocks. 

This function calculates the size of hard internal memory fragmentation between two memory blocks. Hard internal memory fragmentation occurs when there is unused space between the end of the first memory block and the start of the second memory block.


\begin{DoxyParams}{Parameters}
{\em first} & Pointer to the first memory block. \\
\hline
{\em second} & Pointer to the second memory block. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of hard internal memory fragmentation between the two memory blocks. 
\end{DoxyReturn}
\Hypertarget{memory__manager_8h_a8b6e564655ddbbb3147b2d28ee398e5c}\label{memory__manager_8h_a8b6e564655ddbbb3147b2d28ee398e5c} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_get\_new\_vm\_page\_from\_kernel@{mm\_get\_new\_vm\_page\_from\_kernel}}
\index{mm\_get\_new\_vm\_page\_from\_kernel@{mm\_get\_new\_vm\_page\_from\_kernel}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_get\_new\_vm\_page\_from\_kernel()}{mm\_get\_new\_vm\_page\_from\_kernel()}}
{\footnotesize\ttfamily static void \texorpdfstring{$\ast$}{*} mm\+\_\+get\+\_\+new\+\_\+vm\+\_\+page\+\_\+from\+\_\+kernel (\begin{DoxyParamCaption}\item[{int}]{units }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocates a new virtual memory page from the kernel. 

This function allocates a new virtual memory page from the kernel and returns a pointer to the allocated memory block. It uses the {\ttfamily mmap()} system call to request the allocation of memory from the kernel.


\begin{DoxyParams}{Parameters}
{\em units} & The number of memory pages to allocate. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the allocated memory block, or NULL if the allocation fails.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The size of the allocated memory block is determined by multiplying the specified number of units by the system page size (defined by {\ttfamily SYSTEM\+\_\+\+PAGE\+\_\+\+SIZE}).
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
This function should be used with caution as it interacts directly with the kernel to allocate memory. Improper use or misuse of this function can lead to memory leaks or system instability.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
man mmap() 
\end{DoxySeeAlso}
\Hypertarget{memory__manager_8h_ae68e468ad150ea915ed9a3b9d899e9df}\label{memory__manager_8h_ae68e468ad150ea915ed9a3b9d899e9df} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_max\_page\_allocatable\_memory@{mm\_max\_page\_allocatable\_memory}}
\index{mm\_max\_page\_allocatable\_memory@{mm\_max\_page\_allocatable\_memory}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_max\_page\_allocatable\_memory()}{mm\_max\_page\_allocatable\_memory()}}
{\footnotesize\ttfamily static uint32\+\_\+t mm\+\_\+max\+\_\+page\+\_\+allocatable\+\_\+memory (\begin{DoxyParamCaption}\item[{int}]{units }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Calculates the maximum allocatable memory within a virtual memory page. 

This function computes the maximum amount of memory that can be allocated within a virtual memory page, given the number of units specified.


\begin{DoxyParams}{Parameters}
{\em units} & The number of memory units to be allocated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The maximum allocatable memory size in bytes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function takes into account the size of the virtual memory page and subtracts the offset of the page memory within the vm\+\_\+page\+\_\+t structure to determine the available memory for allocation. It is typically used in memory management systems to ensure proper allocation of memory within virtual memory pages. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68}\label{memory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_print\_vm\_page\_details@{mm\_print\_vm\_page\_details}}
\index{mm\_print\_vm\_page\_details@{mm\_print\_vm\_page\_details}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_print\_vm\_page\_details()}{mm\_print\_vm\_page\_details()}}
{\footnotesize\ttfamily void mm\+\_\+print\+\_\+vm\+\_\+page\+\_\+details (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_a3781a6a3593d9877d1c25c4c8e3f1868}{vm\+\_\+page\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page }\end{DoxyParamCaption})}



Prints details of a virtual memory page. 

This function prints detailed information about a virtual memory page, including its next and previous pointers, page family name, and information about each block within the page.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page} & Pointer to the virtual memory page. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{memory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68_icgraph}
\end{center}
\end{figure}
\Hypertarget{memory__manager_8h_ab7ac1212082ab9c61aab19e76696d9ec}\label{memory__manager_8h_ab7ac1212082ab9c61aab19e76696d9ec} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_return\_vm\_page\_to\_kernel@{mm\_return\_vm\_page\_to\_kernel}}
\index{mm\_return\_vm\_page\_to\_kernel@{mm\_return\_vm\_page\_to\_kernel}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_return\_vm\_page\_to\_kernel()}{mm\_return\_vm\_page\_to\_kernel()}}
{\footnotesize\ttfamily static void mm\+\_\+return\+\_\+vm\+\_\+page\+\_\+to\+\_\+kernel (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page,  }\item[{int}]{units }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns a virtual memory page to the kernel. 

This function returns a virtual memory page previously allocated from the kernel back to the kernel. It uses the {\ttfamily munmap()} system call to release the memory.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page} & A pointer to the memory block to be returned to the kernel. \\
\hline
{\em units} & The number of memory pages to return to the kernel.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The size of the memory block to be returned is determined by multiplying the specified number of units by the system page size (defined by {\ttfamily SYSTEM\+\_\+\+PAGE\+\_\+\+SIZE}).
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
This function should be used with caution as it interacts directly with the kernel to release memory. Improper use or misuse of this function can lead to memory leaks or system instability.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
man munmap() 
\end{DoxySeeAlso}
\Hypertarget{memory__manager_8h_ab335253cb154c4adb2beb3cea638fb3c}\label{memory__manager_8h_ab335253cb154c4adb2beb3cea638fb3c} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_split\_free\_data\_block\_for\_allocation@{mm\_split\_free\_data\_block\_for\_allocation}}
\index{mm\_split\_free\_data\_block\_for\_allocation@{mm\_split\_free\_data\_block\_for\_allocation}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_split\_free\_data\_block\_for\_allocation()}{mm\_split\_free\_data\_block\_for\_allocation()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{memory__manager_8h_a8137dde168b63da6dc080c3e41660743}{vm\+\_\+bool\+\_\+t}} mm\+\_\+split\+\_\+free\+\_\+data\+\_\+block\+\_\+for\+\_\+allocation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_ad146e732e35bec81b72c7437204e9ee8}{vm\+\_\+page\+\_\+family\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{vm\+\_\+page\+\_\+family,  }\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{block\+\_\+meta\+\_\+data,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Splits a free data block to allocate a portion of it for memory allocation. 

This function splits a free data block to allocate a portion of it for memory allocation. It checks various cases to determine how the block should be split and whether additional metadata blocks need to be created. After splitting, it updates the metadata of the original block and, if necessary, creates new metadata blocks for the remaining free space.


\begin{DoxyParams}{Parameters}
{\em vm\+\_\+page\+\_\+family} & Pointer to the page family associated with the data block. \\
\hline
{\em block\+\_\+meta\+\_\+data} & Pointer to the metadata of the free data block to be split. \\
\hline
{\em size} & Size of the portion of the block to be allocated.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
MM\+\_\+\+TRUE if the block is successfully split and allocated, MM\+\_\+\+FALSE otherwise.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function assumes that the provided block is free and that the size argument specifies a valid size for memory allocation. It relies on the mm\+\_\+bind\+\_\+blocks\+\_\+for\+\_\+allocation function to establish the link between metadata blocks after splitting. 
\end{DoxyNote}
\Hypertarget{memory__manager_8h_a8b1f18097a67a303b6182eaf288b64f9}\label{memory__manager_8h_a8b1f18097a67a303b6182eaf288b64f9} 
\index{memory\_manager.h@{memory\_manager.h}!mm\_union\_free\_blocks@{mm\_union\_free\_blocks}}
\index{mm\_union\_free\_blocks@{mm\_union\_free\_blocks}!memory\_manager.h@{memory\_manager.h}}
\doxysubsubsection{\texorpdfstring{mm\_union\_free\_blocks()}{mm\_union\_free\_blocks()}}
{\footnotesize\ttfamily static void mm\+\_\+union\+\_\+free\+\_\+blocks (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{first,  }\item[{\mbox{\hyperlink{memory__manager_8h_a173309530f1b69ddabf71b33b75baf9f}{block\+\_\+meta\+\_\+data\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{second }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Merges two contiguous free memory blocks. 

This function merges two contiguous free memory blocks into a single block. The function assumes that both blocks are free and contiguous.


\begin{DoxyParams}{Parameters}
{\em first} & Pointer to the first free memory block. \\
\hline
{\em second} & Pointer to the second free memory block.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function is typically used in memory management systems to optimize memory usage by consolidating adjacent free memory blocks. 
\end{DoxyNote}
